{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE ExistentialQuantification #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE OverloadedStrings #-}

-- | Datatypes for analysis application API.

module DataAnalysis.Application.Types where

import           Control.Exception (Exception)
import           Control.Lens.TH
import           Control.Monad.Trans.Resource
import           Data.ByteString (ByteString)
import           Data.CSV.Conduit
import           Data.CSV.Conduit.Persist
import           Data.Conduit
import qualified Data.Conduit.List as CL
import           Data.Data
import           Data.Default
import           Data.Double.Conversion.Text
import           Data.IORef
import qualified Data.Map                             as Map
import           Data.Maybe
import           Data.Proxy
import           Data.Time
import           Network.HTTP.Conduit (Manager, http, parseUrl, responseBody)
import           Yesod
import           Yesod.Static

data ParseError = ColumnNotFound !Text | CouldNotReadColumn !Text
    deriving (Show, Typeable)
instance Exception ParseError

class FromMapRow a where
    fromMapRow :: MapRow Text -> Either ParseError a
class ToMapRow a where
    toMapRow :: a -> MapRow Text

-- | The type of visualization used to show some data.
data VisualizationType
  = LineChart
  | BarChart
  | PieChart
  deriving (Show,Enum,Eq)

-- | Default chart type to use for data.
instance Default VisualizationType where
  def = LineChart

-- | The format to export data generated by an analysis.
data ExportType
  = CsvData
  | XmlData
  deriving (Show,Read,Enum,Eq)

instance PathPiece ExportType where
  fromPathPiece "csv" = Just CsvData
  fromPathPiece "xml" = Just XmlData
  fromPathPiece _ = Nothing
  toPathPiece CsvData = "csv"
  toPathPiece XmlData = "xml"

-- | Default export type used if none is specified.
instance Default ExportType where
  def = CsvData

-- | A data point which can be rendered onto a chart of some kind.
data DataPoint = DP
  { _dataLabel :: Text
  , _dataValue :: Double
  , _dataGroup :: Maybe Text
  } deriving (Show)

$(makeLenses ''DataPoint)

instance ToMapRow DataPoint where
    toMapRow (DP label value g) =
      Map.fromList [("label",label)
                   ,("value",toShortest value)
                   ,("group",fromMaybe "" g)]

instance ToJSON DataPoint where
  toJSON (DP label value group') =
    case group' of
      Nothing -> toJSON [toJSON label
                        ,toJSON value]
      Just group'' -> toJSON [toJSON label,toJSON value,toJSON group'']

class ManagerReader m where
    askManager :: m Manager
class HasManager a where
    manager :: a -> Manager
instance (HasManager a, MonadUnsafeIO m, MonadThrow m, MonadBaseControl IO m, MonadIO m) => ManagerReader (HandlerT a m) where
    askManager = do
        x <- getYesod
        return $ manager x

class Default a => HasForm a where
    form :: RenderMessage site FormMessage => AForm (HandlerT site IO) a

staticFiles "static/"

-- | Yesod app type.
data App = App
  { appManager  :: !Manager
  , appTitle    :: !Text
  , appAnalysis :: !SomeAnalysis
  , appStatic   :: !Static
  , appStart    :: !UTCTime
  }

instance RenderMessage App FormMessage where
    renderMessage _ _ = defaultFormMessage

-- | Some analysis.
data SomeAnalysis = forall params. SomeAnalysis
  { analysisForm    :: !(AForm (HandlerT App IO) params)
  , analysisConduit :: !(IORef Int -> params -> Conduit ByteString (HandlerT App IO) DataPoint)
  , analysisDefaultParams :: !params
  }

-- | An imported data source.
data DataSource = DataSource
  { srcName      :: !Text
  , srcPath      :: !FilePath
  , srcTimestamp :: !UTCTime
  }

sourceURL :: (MonadResource m, MonadBaseControl IO m, ManagerReader m)
          => String -> Source m ByteString
sourceURL url = do
    req <- liftIO $ parseUrl url
    m <- lift askManager
    res <- lift $ http req m
    (src, _) <- lift $ unwrapResumable $ responseBody res
    src

getSomeAnalysis
  :: (PersistEntity b, HasForm params) =>
     (params -> ConduitM b DataPoint (HandlerT App IO) ())
     -> SomeAnalysis
getSomeAnalysis userAnalysis = SomeAnalysis
    form
    (\countRef params ->
       csvIntoEntities (Proxy :: Proxy b) =$=
       CL.iterM (const (liftIO (modifyIORef' countRef (+1)))) =$=
       CL.mapM (either (monadThrow . Ex) return) =$=
       userAnalysis params)
    def
  where modifyIORef' :: IORef a -> (a -> a) -> IO ()
        modifyIORef' ref f = do
          x <- readIORef ref
          let x' = f x
          x' `seq` writeIORef ref x'

data Ex = Ex Text
  deriving (Data,Show,Typeable,Eq)
instance Exception Ex
