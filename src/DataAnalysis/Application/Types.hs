{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE ExistentialQuantification #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE OverloadedStrings #-}

-- | Datatypes for analysis application API.

module DataAnalysis.Application.Types where

import           Blaze.ByteString.Builder
import           Blaze.ByteString.Builder.Char.Utf8 (fromText)
import           Control.Exception (Exception)
import           Control.Lens.TH
import           Control.Monad.Trans.Resource
import           Data.ByteString (ByteString)
import           Data.CSV.Conduit
import           Data.Conduit
import qualified Data.Conduit.List as CL
import qualified Data.Conduit.Text as CT
import           Data.Default
import           Data.Double.Conversion.Text
import           Data.IORef
import qualified Data.Map                             as Map
import           Data.Maybe
import           Data.Text (Text)
import           Data.Time
import           Data.Typeable (Typeable)
import           Network.HTTP.Conduit (Manager, http, parseUrl, responseBody)
import           Yesod
import           Yesod.Static

data ParseError = ColumnNotFound !Text | CouldNotReadColumn !Text
    deriving (Show, Typeable)
instance Exception ParseError

class FromMapRow a where
    fromMapRow :: MapRow Text -> Either ParseError a
class ToMapRow a where
    toMapRow :: a -> MapRow Text

-- | The type of visualization used to show some data.
data VisualizationType
  = LineChart
  | BarChart
  | PieChart
  deriving (Show,Enum,Eq)

-- | Default chart type to use for data.
instance Default VisualizationType where
  def = LineChart

-- | The format to export data generated by an analysis.
data ExportType
  = JsonData
  | CsvData
  | XmlData
  deriving (Show,Enum,Eq)

-- | Default export type used if none is specified.
instance Default ExportType where
  def = JsonData

-- | A data point which can be rendered onto a chart of some kind.
data DataPoint = DP
  { _dataLabel :: Text
  , _dataValue :: Double
  , _dataGroup :: Maybe Text
  } deriving (Show)

$(makeLenses ''DataPoint)

instance ToMapRow DataPoint where
    toMapRow (DP label value g) =
      Map.fromList [("label",label)
                   ,("value",toShortest value)
                   ,("group",fromMaybe "" g)]

instance ToJSON DataPoint where
  toJSON (DP label value group') =
    case group' of
      Nothing -> toJSON [toJSON label
                        ,toJSON value]
      Just group'' -> toJSON [toJSON label,toJSON value,toJSON group'']

class ManagerReader m where
    askManager :: m Manager
class HasManager a where
    manager :: a -> Manager
instance (HasManager a, MonadUnsafeIO m, MonadThrow m, MonadBaseControl IO m, MonadIO m) => ManagerReader (HandlerT a m) where
    askManager = do
        x <- getYesod
        return $ manager x

class Default a => HasForm a where
    form :: RenderMessage site FormMessage => AForm (HandlerT site IO) a

staticFiles "static/"

-- | Yesod app type.
data App = App
  { appManager  :: !Manager
  , appTitle    :: !Text
  , appAnalysis :: !SomeAnalysis
  , appStatic   :: !Static
  , appStart    :: !UTCTime
  }

instance RenderMessage App FormMessage where
    renderMessage _ _ = defaultFormMessage

-- | Some analysis.
data SomeAnalysis = forall params. SomeAnalysis
  { analysisForm    :: !(AForm (HandlerT App IO) params)
  , analysisConduit :: !(IORef Int -> params -> Conduit ByteString (HandlerT App IO) DataPoint)
  , analysisDefaultParams :: !params
  }

-- | An imported data source.
data DataSource = DataSource
  { srcName      :: !Text
  , srcPath      :: !FilePath
  , srcTimestamp :: !UTCTime
  }

sourceURL :: (MonadResource m, MonadBaseControl IO m, ManagerReader m)
          => String -> Source m ByteString
sourceURL url = do
    req <- liftIO $ parseUrl url
    m <- lift askManager
    res <- lift $ http req m
    (src, _) <- lift $ unwrapResumable $ responseBody res
    src

analysisBSConduitCSV
    :: (MonadResource m, MonadBaseControl IO m, FromMapRow input, ToMapRow output)
    => Conduit input m output
    -> Conduit ByteString m (Flush Builder)
analysisBSConduitCSV inner =
        CT.decode CT.utf8
    =$= intoCSV defCSVSettings
    =$= CL.mapM fromMapRow'
    =$= inner
    =$= CL.map toMapRow
    =$= (writeHeaders defCSVSettings >> fromCSV defCSVSettings)
    =$= CL.map (Chunk . fromText)

analysisBSConduitJSON
    :: (MonadResource m, MonadBaseControl IO m, FromMapRow input)
    => IORef Int
    -> Conduit input m DataPoint
    -> Conduit ByteString m DataPoint
analysisBSConduitJSON countRef inner =
        CT.decode CT.utf8
    =$= intoCSV defCSVSettings
    =$= CL.iterM (const (liftIO (modifyIORef' countRef (+1))))
    =$= CL.mapM fromMapRow'
    =$= inner
  where modifyIORef' :: IORef a -> (a -> a) -> IO ()
        modifyIORef' ref f = do
            x <- readIORef ref
            let x' = f x
            x' `seq` writeIORef ref x'

fromMapRow' :: (FromMapRow a, MonadThrow m) => MapRow Text -> m a
fromMapRow' = either monadThrow return . fromMapRow

getSomeAnalysis :: (HasForm params, FromMapRow input, Default params)
                => (params -> Conduit input (HandlerT App IO) DataPoint)
                -> SomeAnalysis
getSomeAnalysis analysisOf = SomeAnalysis
    form
    (\countRef params -> analysisBSConduitJSON countRef (analysisOf params))
    def
